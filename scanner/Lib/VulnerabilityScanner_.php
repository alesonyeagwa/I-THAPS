<?php
$globalVulnerabilities = new VulnerabilityStorage();
$bodyTraverser = new PhpParser\NodeTraverser;

class THAPS_PHPParser_Node_LoopExpanded extends PhpParser\NodeAbstract
{
    public function __construct(array $items = array(), $line = -1, $fileName, $docComment = null)
    {
        parent::__construct(
            array(
                "subNodes" => array(
                    'items' => $items
                ),
                "startLine" => $line,
                "fileName" => $fileName,
                "comments" => array($docComment)
            )
        );
    }
    /**
     * Gets the type of the node.
     *
     * @return string Type of the node
     */
    public function getType() : string {
        return substr(get_class($this), 15);
    }

    /**
     * Gets the names of the sub nodes.
     *
     * @return array Names of sub nodes
     */
    public function getSubNodeNames() : array {
        return array_keys($this->getAttribute("subNodes"));
    }
}

class THAPS_PHPParser_Node_SwitchExpanded extends PhpParser\NodeAbstract
{
    public function __construct(array $cases = array(), $fileName, $line = -1, $docComment = null)
    {
        parent::__construct(
            array(
                "subNodes" => array(
                    'cases' => $cases
                ),
                "startLine" => $line,
                "fileName" => $fileName,
                "comments" => array($docComment)
            )
        );
    }

    /**
     * Gets the type of the node.
     *
     * @return string Type of the node
     */
    public function getType() : string {
        return substr(get_class($this), 15);
    }

    /**
     * Gets the names of the sub nodes.
     *
     * @return array Names of sub nodes
     */
    public function getSubNodeNames() : array {
        return array_keys($this->getAttribute("subNodes"));
    }
}

class BodyVisitor extends PhpParser\NodeVisitorAbstract
{
    /**
     * @var bool decides if full tree should be used, or equal branches should be removed.
     */
    private static $fullTree = false;

    public static function useFullTree($on)
    {
        self::$fullTree = $on;
    }

    private static $postCleanSQL = false;
    private static $postCleanXSS = false;
    private static $postCleanFI = false;
    private static $getCleanSQL = false;
    private static $getCleanXSS = false;
    private static $getCleanFI = false;
    private static $cookieCleanSQL = false;
    private static $cookieCleanXSS = false;
    private static $cookieCleanFI = false;
    private static $requestCleanSQL = false;
    private static $requestCleanXSS = false;
    private static $requestCleanFI = false;

    public static function useCleanGetPost($sql, $xss)
    {
        self::$postCleanSQL = $sql;
        self::$postCleanXSS = $xss;
        self::$postCleanFI = $xss;
        self::$getCleanSQL = $sql;
        self::$getCleanXSS = $xss;
        self::$getCleanFI = $xss;
        self::$cookieCleanSQL = $sql;
        self::$cookieCleanXSS = $xss;
        self::$cookieCleanFI = $xss;
        self::$requestCleanSQL = $sql;
        self::$requestCleanXSS = $xss;
        self::$requestCleanXSS = $xss;
    }

    /**
     * @var int Defined how many times loops should be unrolled
     */
    private $loopExpandTimes = 1;

    public function setLoopExpandTimes($times)
    {
        $this->loopExpandTimes = $times;
    }

    /**
     * @var VulnerabilityStorage
     */
    public $vulnerabilities;

    public function setVulnerabilityStorage(VulnerabilityStorage &$vulnerabilities)
    {
        $this->vulnerabilities = $vulnerabilities;
    }

    public function getVulnerabilities()
    {
        return $this->vulnerabilities;
    }

    /**
     * @var VariableStorage
     */
    private $vScope;

    public function setVScope(VariableStorage $storage)
    {
        $this->vScope = $storage;
    }

    public function getVScope()
    {
        return $this->vScope;
    }

    /**
     * @var array
     */
    private $dependencies = null;

    public function setDependencies($deps)
    {
        $this->dependencies = $deps;
    }


    /**
     * @var VariableValue
     */
    private $taint;

    public function getTaint()
    {
        return $this->taint;
    }

    /**
     * When an if is left, this is used to determine if the scopes is unnessary.
     * @var VariableStorage[][]
     */
    private $ifScopes = array();


    public static $lastNode = -1;


      /**
     * @var string
     */
    private $fileName;

    public function setFileName($fileName){
        $this->fileName = $fileName;
    }

    public function getFileName(){
        return $this->fileName;
    }


    public function beforeTraverse(array $nodes)
    {
        if ($this->dependencies == null) {
            $this->dependencies = array();
        }

        $this->taint = new VariableValue();
    }

    public function afterTraverse(array $nodes)
    {
        return $this->vulnerabilities->get();
    }

    private static $ignoreProgress = false;

    public function enterNode(PhpParser\Node $node)
    {
        global $totalNodeCount, $stepSize;

        if ($node->getLine() == 143) {
            //echo "najs";
        }

        if($node->getAttribute("fileName") == NULL){
            //die($this->fileName);
            $node->setAttribute("fileName", $this->fileName);
        }else{
            $this->setFileName($node->getAttribute("fileName"));
        }

        //echo(var_dump($node));
        global $globalVScope;
        //var_dump($globalVScope);
        global $silent;
        if (!$silent && !self::$ignoreProgress && $node->getAttribute("nodeNumber") > 0 && $node->getAttribute("nodeNumber") % $stepSize == 0 && self::$lastNode != $node->getAttribute("nodeNumber")) {
            echo "Progress @ " . date("H:i:s") . " - " . $node->getAttribute("nodeNumber") . "/" . $totalNodeCount . "\n";
            self::$lastNode = $node->getAttribute("nodeNumber");
        }

        /*
         * Control flow structures
         * Currently only IF/THEN/ELSE
         */
        if ($node instanceof PhpParser\Node\Stmt\If_) {
            self::$ignoreProgress = true;
            // Create the new scopes for each if/elseif and else in the proper locatations
            $possiblePlaces = $this->vScope->getDependencyStorage($this->dependencies);
            $this->ifScopes[] = $possiblePlaces;

            // Make accessment of condition, it might secure some variables
            $conditionVisitor = new ConditionVisitor();
            $conditionTranverser = new PhpParser\NodeTraverser();
            $conditionTranverser->addVisitor($conditionVisitor);
            $conditionTranverser->traverse(array($node->cond));
            $cleanVars = $conditionVisitor->getCleanedVars();

            foreach ($possiblePlaces as $possiblePlace) {
                $cond = $node->getAttribute("fileName") . ":" . $node->getLine() . ":if (" . printNode($node->cond, true) . ")";

                $groupId = uniqid();

                // For each of the cleaned vars lets check if they are dangerous
                $storage = $possiblePlace->addSubstorage($cond, false, $groupId);
                //var_dump($possiblePlace);
                $taintTraverser = new PhpParser\NodeTraverser;
                $taintVisitor = new BodyVisitor;
                $taintVisitor->setVScope($storage);
                $taintVisitor->setFileName($this->fileName);
                $taintVisitor->setDependencies($this->dependencies);
                $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                $taintTraverser->addVisitor($taintVisitor);

                if (is_array($cleanVars))
                    foreach ($cleanVars as $cleanVar) {
                        $taintTraverser->traverse(array($cleanVar));
                        $taint = $taintVisitor->getTaint();

                        if ($taint instanceof VariableValue && $taint->userInput) {
                            $taint->xss = false;
                            $taint->sql = false;
                            $taint->fi = false;
                            $taint->value = str_replace(array("_SQL", "_XSS", "_FI"), "", $taint->value);
                            $assignArray = $this->findVarNameAndDim($cleanVar, $taintTraverser, $taintVisitor);
                            array_unshift($assignArray, $taint);
                            call_user_func_array(array($storage, 'setVariableValue'), $assignArray);
                        }
                    }

                if ($node->elseifs !== null) {
                    foreach ($node->elseifs as $elseif) {
                        if($elseif->getAttribute("fileName") == NULL){
                            $elseif->setAttribute("fileName", $this->fileName);
                        }
                        $cond = $elseif->getAttribute("fileName") . ":" . $elseif->getLine() . ":elseif (" . printNode($elseif->cond, true) . ")";
                        $storage = $possiblePlace->addSubstorage($cond, false, $groupId);

                        // Make accessment of condition, it might secure some variables
                        $conditionVisitor = new ConditionVisitor();
                        $conditionTranverser = new PhpParser\NodeTraverser();
                        $conditionTranverser->addVisitor($conditionVisitor);
                        $conditionTranverser->traverse(array($elseif->cond));
                        $cleanVars = $conditionVisitor->getCleanedVars();

                        $taintTraverser = new PhpParser\NodeTraverser;
                        $taintVisitor = new BodyVisitor;
                        $taintVisitor->setFileName($this->fileName);
                        $taintVisitor->setVScope($storage);
                        $taintVisitor->setDependencies($this->dependencies);
                        $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                        $taintTraverser->addVisitor($taintVisitor);

                        if (is_array($cleanVars))
                            foreach ($cleanVars as $cleanVar) {
                                $taintTraverser->traverse(array($cleanVar));
                                $taint = $taintVisitor->getTaint();

                                if ($taint instanceof VariableValue && $taint->userInput) {
                                    $taint->xss = false;
                                    $taint->sql = false;
                                    $taint->fi = false;
                                    $taint->value = str_replace(array("_SQL", "_XSS", "_FI"), "", $taint->value);
                                    $assignArray = $this->findVarNameAndDim($cleanVar, $taintTraverser, $taintVisitor);
                                    array_unshift($assignArray, $taint);
                                    call_user_func_array(array($storage, 'setVariableValue'), $assignArray);
                                }
                            }

                    }
                }
                if (($else = $node->else) !== null) {
                    if($else->getAttribute("fileName") == NULL){
                        $else->setAttribute("fileName", $this->fileName);
                    }
                    $cond = $else->getAttribute("fileName") . ":" . $else->getLine() . ":else";
                    $possiblePlace->addSubstorage($cond, true, $groupId);
                }
            }

            // Set the current dependencies for the futher scan
            $this->dependencies[] = $node->getAttribute("fileName") . ":" . $node->getLine() . ":if (" . printNode($node->cond, true) . ")";
            self::$ignoreProgress = false;
        }
        elseif ($node instanceof PhpParser\Node\Stmt\ElseIf_) {
            // Pop the old dependency which will be the if or a prior elseif and add the elseif
            array_pop($this->dependencies);
            $this->dependencies[] = $node->getAttribute("fileName") . ":" . $node->getLine() . ":elseif (" . printNode($node->cond, true) . ")";
        }
        elseif ($node instanceof PhpParser\Node\Stmt\Else_) {
            // Pop the old dependency which will be the if or an elseif and add the else
            array_pop($this->dependencies);
            $this->dependencies[] = $node->getAttribute("fileName") . ":" . $node->getLine() . ":else";
        }
        elseif ($node instanceof PhpParser\Node\Stmt\Switch_) {
            $possiblePlaces = $this->vScope->getDependencyStorage($this->dependencies);

            $this->ifScopes[] = $possiblePlaces;

            $remove = array();

            $merge = array();
            $concat = array();
            $default = false;
            $groupId = uniqid();
            foreach ($node->cases as $index => $case) {
                //
                if (count($case->stmts) == 0) {
                    $merge[] = $case;
                    $remove[] = $index;

                    if ($case->cond == null) {
                        $case->cond = new PhpParser\Node\Scalar\String_("__default__", array("startLine" => $case->getLine(), "fileName" => $case->getAttribute("fileName"), "comments" => array($case->getDocComment())));
                        $default = true;
                    }
                }
                else if ($case->stmts[count($case->stmts) - 1] instanceof PhpParser\Node\Stmt\Break_) {
                    /**
                     * add stmts to earliers cases without break;
                     */
                    if (count($concat) > 0) {
                        foreach ($concat as $tmpcase) {
                            $tmpcase->stmts = array_merge($tmpcase->stmts, unserialize(serialize($case->stmts)));
                        }

                        $concat = array();
                    }


                    if ($case->cond == null) {
                        $case->cond = new PhpParser\Node\Scalar\String_("__default__", array("startLine" => $case->getLine(), "fileName" => $case->getAttribute("fileName"), "comments" => array($case->getDocComment())));
                        $default = true;
                    }
                    /**
                     * Merge empty
                     */
                    if (count($merge) > 0) {
                        foreach ($merge as $tmpcase) {
                            $case->cond = new PhpParser\Node\Expr\BinaryOp\LogicalOr($tmpcase->cond, $case->cond, array("startLine" => $tmpcase->getLine(), "fileName" => $tmpcase->getAttribute("fileName"), "comments" => array($tmpcase->getDocComment())));
                        }

                        $merge = array();
                    }
                    if($case->getAttribute("fileName") == NULL){
                        $case->setAttribute("fileName", $this->fileName);
                    }
                    $cond = $case->getAttribute("fileName") . ":" . $case->getLine() . ":case " . printNode($case->cond, true);
                    foreach ($possiblePlaces as $possiblePlace) {
                        $possiblePlace->addSubstorage($cond, $default, $groupId);
                    }
                } else {
                    $concat[] = $case;

                    if ($case->cond == null) {
                        $case->cond = new PhpParser\Node\Scalar\String_("__default__", array("startLine" => $case->getLine(), "fileName" => $case->getAttribute("fileName"), "comments" => array($case->getDocComment())));
                        $default = true;
                    }
                    if($case->getAttribute("fileName") == NULL){
                        $case->setAttribute("fileName", $this->fileName);
                    }
                    $cond = $case->getAttribute("fileName") . ":" . $case->getLine() . ":case " . printNode($case->cond, true);

                    foreach ($possiblePlaces as $possiblePlace) {
                        $possiblePlace->addSubstorage($cond, $default, $groupId);
                    }

                }
            }

            foreach ($remove as $index) {
                array_splice($node->cases, $index, 1);
            }

            // Add empty dependency to remove at first case
            $this->dependencies[] = "FAKE FOR SWITCH CASE";

        }
        elseif ($node instanceof PhpParser\Node\Stmt\Case_) {
            array_pop($this->dependencies);
            $cond = $node->getAttribute("fileName") . ":" . $node->getLine() . ":case " . printNode($node->cond, true);
            $this->dependencies[] = $cond;
        }
        elseif ($node instanceof PhpParser\Node\Stmt\For_) {
            // Expand the for loop
            $nodes = array_merge($node->init, $node->stmts, $node->loop);
            for ($i = 1; $i < $this->loopExpandTimes; $i++) {
                $nodes = array_merge($nodes, $node->stmts);
                $nodes = array_merge($nodes, $node->loop);
            }
            $tmp = new THAPS_PHPParser_Node_LoopExpanded($nodes, $node->getLine(), $node->getAttribute("fileName"), $node->getDocComment());

            return $tmp;
        }
        elseif ($node instanceof PhpParser\Node\Stmt\While_) {
            // Expand the while loop
            $nodes = $node->stmts;
            for ($i = 1; $i < $this->loopExpandTimes; $i++) {
                $nodes = array_merge($nodes, $node->stmts);
            }
            $tmp = new THAPS_PHPParser_Node_LoopExpanded($nodes, $node->getLine(), $node->getAttribute("fileName"), $node->getDocComment());

            return $tmp;
        }
        elseif ($node instanceof PhpParser\Node\Stmt\Foreach_) {
            // Lets detect if the foreach is a specific clean for
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor;
            $taintVisitor->setVScope($this->vScope);
            $taintVisitor->setFileName($this->fileName);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
            $taintTraverser->addVisitor($taintVisitor);
            $taintTraverser->traverse(array($node->expr));
            $varTaint = $taintVisitor->getTaint();

            // might be an array - we only care for the first value, it might be dangerous
            while (is_array($varTaint)) {
                $varTaint = array_pop($varTaint);
            }

            //
            // Detech foreach (..$_POST/GET.. ) $_POST/GET = ...
            //
            if ($varTaint instanceof VariableValue && $varTaint->userInput && count($varTaint->flowpath) == 0 &&
                count($node->stmts) == 1 && $node->stmts[0] instanceof PhpParser\Node\Expr\Assign && $node->stmts[0]->var instanceof PhpParser\Node\Expr\ArrayDimFetch &&
                ($node->stmts[0]->var->var->name == "_POST" || $node->stmts[0]->var->var->name == "_GET" || $node->stmts[0]->var->var->name == "_COOKIE" || $node->stmts[0]->var->var->name == "_REQUEST")
            ) {

                $funcCallTraverser = new PhpParser\NodeTraverser();
                $funcCallVisitor = new FunctionCallResolver();
                $funcCallTraverser->addVisitor($funcCallVisitor);
                $funcCallTraverser->traverse($node->stmts);

                global $SECURING_ALL, $SECURING_XSS, $SECURING_SQL, $SECURING_FI;

                $all = count(array_intersect($SECURING_ALL, $funcCallVisitor->getFuncCallList())) != 0;
                $xss = count(array_intersect($SECURING_XSS, $funcCallVisitor->getFuncCallList())) != 0;
                $sql = count(array_intersect($SECURING_SQL, $funcCallVisitor->getFuncCallList())) != 0;
                $fi = count(array_intersect($SECURING_FI, $funcCallVisitor->getFuncCallList())) != 0;


                if ($node->stmts[0]->var->var->name == "_POST") {
                    if ($sql || $all) {
                        self::$postCleanSQL = true;
                    }
                    if ($xss || $all) {
                        self::$postCleanXSS = true;
                    }
                    if($fi || $all){
                        self::$postCleanFI = true;
                    }
                } else if ($node->stmts[0]->var->var->name == "_GET") {
                    if ($sql || $all) {
                        self::$getCleanSQL = true;
                    }
                    if ($xss || $all) {
                        self::$getCleanXSS = true;
                    }
                    if($fi || $all){
                        self::$getCleanFI = true;
                    }
                } else if ($node->stmts[0]->var->var->name == "_COOKIE") {
                    if ($sql || $all) {
                        self::$cookieCleanSQL = true;
                    }
                    if ($xss || $all) {
                        self::$cookieCleanXSS = true;
                    }
                    if($fi || $all){
                        self::$cookieCleanFI = true;
                    }
                } else if ($node->stmts[0]->var->var->name == "_REQUEST") {
                    if ($sql || $all) {
                        self::$requestCleanSQL = true;
                    }
                    if ($xss || $all) {
                        self::$requestCleanXSS = true;
                    }
                    if($fi || $all){
                        self::$requestCleanFI = true;
                    }
                }
                return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
            } else {
                // TODO: expand the foreach loop

            }
        }
        /**
         * Remove the boolean expr, as they do the same stuff, nothing
         */
        elseif ($node instanceof PhpParser\Node\Expr\BinaryOp\Equal ||
            $node instanceof PhpParser\Node\Expr\BinaryOp\NotEqual ||
            $node instanceof PhpParser\Node\Expr\BinaryOp\Greater ||
            $node instanceof PhpParser\Node\Expr\BinaryOp\GreaterOrEqual ||
            $node instanceof PhpParser\Node\Expr\BinaryOp\Smaller ||
            $node instanceof PhpParser\Node\Expr\BinaryOp\SmallerOrEqual ||
            $node instanceof PhpParser\Node\Expr\BinaryOp\BooleanAnd ||
            $node instanceof PhpParser\Node\Expr\BooleanNot ||
            $node instanceof PhpParser\Node\Expr\BinaryOp\BooleanOr ||
            $node instanceof PhpParser\Node\Expr\BinaryOp\Identical
        ) {
            $this->taint = new VariableValue();
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Expr\BinaryOp\LogicalOr ||
            $node instanceof PhpParser\Node\Expr\BinaryOp\LogicalAnd ||
            $node instanceof PhpParser\Node\Expr\BinaryOp\LogicalXor
        ) {
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor();
            $taintVisitor->setVScope($this->vScope);
            $taintVisitor->setFileName($this->fileName);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
            $taintTraverser->addVisitor($taintVisitor);

            $taintTraverser->traverse(array($node->left));
            $leftTaint = $taintVisitor->getTaint();
            $taintTraverser->traverse(array($node->right));
            $rightTaint = $taintVisitor->getTaint();

            $this->taint = new VariableValue();
            if ($leftTaint === null && $rightTaint !== null) {
                $this->taint = $rightTaint;
            } elseif ($leftTaint !== null && $rightTaint === null) {
                $this->taint = $leftTaint;
            } elseif ($leftTaint !== null && $rightTaint !== null) {
                if ($leftTaint instanceof VariableValue && $rightTaint instanceof VariableValue) {
                    $this->taint->userInput = $leftTaint->userInput || $rightTaint->userInput;
                    $this->taint->xss = $leftTaint->xss || $rightTaint->xss;
                    $this->taint->sql = $leftTaint->sql || $rightTaint->sql;
                    $this->taint->fi = $leftTaint->fi || $rightTaint->fi;
                } else {
                    // This is wrong, need to be better if left and right are complex
                    $this->taint = $leftTaint;
                }
            }

            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        /**
         * INT, BOOL and DOUBLE casts makes value safe
         */
        elseif ($node instanceof PhpParser\Node\Expr\Cast\Bool_ ||
            $node instanceof PhpParser\Node\Expr\Cast\Double ||
            $node instanceof PhpParser\Node\Expr\Cast\Int_
        ) {

            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor;
            $taintVisitor->setVScope($this->vScope);
            $taintVisitor->setFileName($this->fileName);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
            $taintTraverser->addVisitor($taintVisitor);
            $taintTraverser->traverse(array($node->expr));
            $varTaint = $taintVisitor->getTaint();

            $this->taint = new VariableValue();
            $this->taint->value = str_replace(array("USERINPUT", "_XSS", "_SQL", "_FI"), array("USERCASTEDINPUT", "", ""), $varTaint->value);

            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        /**
         * Get variable values - these should only be hit where the vScope is a single target,
         * as they are a part of the taint evaluation - maybe that is ;)
         *  - Torben
         */
        elseif ($node instanceof PhpParser\Node\Expr\Variable) {
            $val = $this->vScope->getVariableValue($node->name);
            if ($val !== null) {
                $this->taint = $val;
                //if ($node->name == "_POST")
                   /// echo(var_dump($this->taint));
            } else if ($node->name == "_POST") {
                $var = new VariableValue();
                $var->userInput = true;
                $var->xss = self::$postCleanXSS;
                $var->sql = self::$postCleanSQL;
                $var->fi = self::$postCleanFI;
                $this->taint = array($var);
               // echo(var_dump($this->taint));
            } else if ($node->name == "_GET") {
                $var = new VariableValue();
                $var->userInput = true;
                $var->xss = self::$getCleanXSS;
                $var->sql = self::$getCleanSQL;
                $var->fi = self::$getCleanFI;
                $this->taint = array($var);
            } else if ($node->name == "_COOKIE") {
                $var = new VariableValue();
                $var->userInput = true;
                $var->xss = self::$cookieCleanXSS;
                $var->sql = self::$cookieCleanSQL;
                $var->fi = self::$cookieCleanFI;
                $this->taint = array($var);
            } else if ($node->name == "_REQUEST") {
                $var = new VariableValue();
                $var->userInput = true;
                $var->xss = self::$requestCleanXSS;
                $var->sql = self::$requestCleanSQL;
                $var->fi = self::$requestCleanFI;
                $this->taint = array($var);
            }
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Expr\ArrayDimFetch) {
            // Find the value of an array dim fetch
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor;
            $taintVisitor->setVScope($this->vScope);
            $taintVisitor->setFileName($this->fileName);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
            $taintTraverser->addVisitor($taintVisitor);
            $taintTraverser->traverse(array($node->dim));
            $dimVal = $taintVisitor->getTaint()->value;
            $dim = array($dimVal);
            $target = $node;

            // If multidimension is hit
            while ($target->var instanceof PhpParser\Node\Expr\ArrayDimFetch) {
                $target = $target->var;
                $taintTraverser->traverse(array($target->dim));
                $dimVal = $taintVisitor->getTaint()->value;
                array_unshift($dim, $dimVal);
            }
            array_unshift($dim, $target->var->name);

            $val = call_user_func_array(array($this->vScope, 'getVariableValue'), $dim);
            
            if ($val !== null) {
                $this->taint = $val;
            } else if ($target->var->name == "_POST") {
                // If the value is not found and we are talking POST or GET variables then "invent" them
                $this->taint->userInput = true;
                $this->taint->value = "{USERINPUT" . (self::$postCleanSQL ? "" : "_SQL") . (self::$postCleanXSS ? "" : "_XSS") .  (self::$postCleanFI ? "" : "_FI") ."}";
                $this->taint->xss = !self::$postCleanXSS;
                $this->taint->sql = !self::$postCleanSQL;
                $this->taint->fi = !self::$postCleanFI;
            } else if ($target->var->name == "_GET") {
                $this->taint->userInput = true;
                $this->taint->value = "{USERINPUT" . (self::$getCleanSQL ? "" : "_SQL") . (self::$getCleanXSS ? "" : "_XSS") . (self::$getCleanFI ? "" : "_FI") ."}";
                $this->taint->xss = !self::$getCleanXSS;
                $this->taint->sql = !self::$getCleanSQL;
                $this->taint->fi = !self::$getCleanFI;
            } else if ($target->var->name == "_COOKIE") {
                $this->taint->userInput = true;
                $this->taint->value = "{USERINPUT" . (self::$cookieCleanSQL ? "" : "_SQL") . (self::$cookieCleanXSS ? "" : "_XSS") . (self::$cookieCleanFI ? "" : "_FI") ."}";
                $this->taint->xss = !self::$cookieCleanXSS;
                $this->taint->sql = !self::$cookieCleanSQL;
                $this->taint->fi = !self::$cookieCleanFI;
            } else if ($target->var->name == "_REQUEST") {
                $this->taint->userInput = true;
                $this->taint->value = "{USERINPUT" . (self::$requestCleanSQL ? "" : "_SQL") . (self::$requestCleanXSS ? "" : "_XSS") . (self::$requestCleanFI ? "" : "_FI") ."}";
                $this->taint->xss = !self::$requestCleanXSS;
                $this->taint->sql = !self::$requestCleanSQL;
                $this->taint->fi = !self::$requestCleanFI;
            }
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Expr\PropertyFetch) {
            // Get a property of an object
            $class = $this->vScope->getVariableValue($node->var->name);
            if (!($class instanceof ClassDescription)) {
                return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
            }
            $property = $class->getProperty($node->name);

            if ($property !== null) {
                $this->taint = $this->vScope->getVariableValue($node->var->name, $node->name);
            }
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Expr\StaticPropertyFetch) {
            // Static variables are saved on class name level
            $this->taint = $this->vScope->getVariableValue(VAR_REP_STATIC . $node->class->parts[0], $node->name);
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Expr\ClassConstFetch) {
            $className = $node->class->parts[0];
            $name = $node->name;

            if ($className == "self") {
                global $parsedClass;
                $className = $parsedClass;
            }

            if (($class = ClassStorage::getClass($className)) !== null) {
                if (isset($class->constants[$name])) {
                    $this->taint = new VariableValue();
                    $this->taint->value = $class->constants[$name]->value;
                }
            }
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Expr\ConstFetch) {
            $target = $this->vScope;
            while ($target->parentScope !== null) {
                $target = $target->parentScope;
            }

            if (defined(end($node->name->parts))) {
                $this->taint = new VariableValue();
                eval('$this->taint->value=' . end($node->name->parts) . ';');
            } else {
                $this->taint = $target->getVariableValue(VAR_REP_CONST . end($node->name->parts));
                if ($this->taint === null) {
                    // Constants that are not defined are apparently defaulted to a string
                    $this->taint = new VariableValue();
                    $this->taint->value = end($node->name->parts);
                }
            }


            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Expr\BinaryOp\Concat) {
            // Concat, simple taint traverse both sides and .. concat.
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor();
            $taintVisitor->setVScope($this->vScope);
            $taintVisitor->setFileName($this->fileName);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
            $taintTraverser->addVisitor($taintVisitor);

            $taintTraverser->traverse(array($node->left));
            $leftTaint = $taintVisitor->getTaint();
            $taintTraverser->traverse(array($node->right));
            $partTaint = $taintVisitor->getTaint();

            // echo "Left Taint\n";
            // echo(var_dump($leftTaint));
            // echo "\n\Right Taint\n";
            // echo(var_dump($partTaint));
            // if($partTaint->userInput){
            //     die(var_dump($node->right));
            // }
            // // echo "\n\nthis Taint\n";
            // // echo(var_dump($this->taint));
            // echo(var_dump($node));

            // echo "\n\nNode\n";
            // echo(var_dump($node));


            if(is_array($leftTaint)){
                $leftTaint = squeezeTaints($leftTaint);
            }
            if(is_array($partTaint)){
                $partTaint = squeezeTaints($partTaint);
            }

            if(is_array($this->taint)){
                $this->taint = squeezeTaints($this->taint);
            }

            $this->taint->userInput = $leftTaint->userInput || $partTaint->userInput;
            $this->taint->xss = $leftTaint->xss || $partTaint->xss;
            $this->taint->sql = $leftTaint->sql || $partTaint->sql;
            $this->taint->fi = $leftTaint->fi || $partTaint->fi;

            if ($this->taint->userInput) {
                if ($leftTaint->userInput && !$partTaint->userInput) {
                    $this->taint->flowpath = $leftTaint->flowpath;
                    $this->taint->dependencies = $leftTaint->dependencies;
                } else if (!$leftTaint->userInput) {
                    $this->taint->flowpath = $partTaint->flowpath;
                    $this->taint->dependencies = $partTaint->dependencies;
                } else {
                    $this->taint->flowpath = array_merge($leftTaint->flowpath, $partTaint->flowpath);
                    $this->taint->dependencies = array_merge($leftTaint->dependencies, $partTaint->dependencies);
                }
            }


            $this->taint->value = $leftTaint->value . $partTaint->value;

            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Scalar\Encapsed) {
            // String with included variables - i.e. "hello $name"
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor();
            $taintVisitor->setVScope($this->vScope);
            $taintVisitor->setFileName($this->fileName);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
            $taintTraverser->addVisitor($taintVisitor);

            for ($i = 0; $i < count($node->parts); $i++) {
                if ($node->parts[$i] instanceof PhpParser\Node && !($node->parts[$i] instanceof PhpParser\Node\Scalar\EncapsedStringPart)) {
                    if($node->parts[$i]->getAttribute("fileName") == NULL){
                        $node->parts[$i]->setAttribute("fileName",$this->fileName);
                    }
                    $taintTraverser->traverse(array($node->parts[$i]));
                    $partTaint = $taintVisitor->getTaint();

                    $old = $this->taint->userInput;
                    $this->taint->userInput = $this->taint->userInput || $partTaint->userInput;
                    $this->taint->xss = $this->taint->xss || $partTaint->xss;
                    $this->taint->sql = $this->taint->sql || $partTaint->sql;
                    $this->taint->fi = $this->taint->fi || $partTaint->fi;
                    if ($this->taint->userInput) {
                        if (!$old) {
                            $this->taint->flowpath = $partTaint->flowpath;
                            $this->taint->dependencies = $partTaint->dependencies;
                        } else {
                            $this->taint->flowpath = array_merge($this->taint->flowpath, $partTaint->flowpath);
                            $this->taint->dependencies = array_merge($this->taint->dependencies, $partTaint->dependencies);
                        }
                    }
                    $this->taint->value = $this->taint->value . $partTaint->value;
                } else {
                    $this->taint->value = $this->taint->value . $node->parts[$i]->value;
                }
            }

            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Scalar\MagicConst\File) {
            $this->taint->value = $node->getAttribute("fileName");
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Scalar\String_ ||
            $node instanceof PhpParser\Node\Scalar\LNumber ||
            $node instanceof PhpParser\Node\Scalar\DNumber
        ) {
            $this->taint->value = $node->value;
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Expr\Array_) {
            $array = array();
            foreach ($node->items as $item) {
                $taintTraverser = new PhpParser\NodeTraverser;
                $taintVisitor = new BodyVisitor();
                $taintVisitor->setVScope($this->vScope);
                $taintVisitor->setFileName($this->fileName);
                $taintVisitor->setDependencies($this->dependencies);
                $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                $taintTraverser->addVisitor($taintVisitor);
                $taintTraverser->traverse(array($item->value));
                $val = $taintVisitor->getTaint();
                if ($item->key !== null) {
                    $taintTraverser->traverse(array($item->key));
                    $key = $taintVisitor->getTaint()->value;
                    $array[$key] = $val;
                } else {
                    $array[] = $val;
                }
            }

            $this->taint = $array;
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        /**
         * Function and method calls
         */
        elseif ($node instanceof PhpParser\Node\Expr\FuncCall) {
            global $functions;
            //echo(var_dump($node));
            $funcName = $node->name->parts[0];

            global $SECURING_ALL, $SECURING_XSS, $SECURING_SQL, $INSECURING_USERINPUT, $XSS_SINKS;

            if (in_array($funcName, $SECURING_XSS)) {
                $taintTraverser = new PhpParser\NodeTraverser;
                $taintVisitor = new BodyVisitor();
                $taintVisitor->setFileName($this->fileName);
                $taintVisitor->setDependencies($this->dependencies);
                $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                $taintTraverser->addVisitor($taintVisitor);

                $args = $node->args;
                foreach ($args as $nr => $arg) {
                    $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                    // var_dump($this->dependencies);
                    // var_dump($globalVScope);
                    foreach ($varValueConfigurations as $varValueConfiguration) {
                        $taintVisitor->setVScope($varValueConfiguration);
                        $taintTraverser->traverse(array($arg->value));
                        $this->taint = $taintVisitor->getTaint();
                    }
                }
                if(strpos(end($this->dependencies), "if") !== false || 
                    strpos(end($this->dependencies), "elseif") !== false ||
                    strpos(end($this->dependencies), "else") !== false ||
                    strpos(end($this->dependencies), "case") !== false ){
                    $this->taint->possible = true;
                }
                $this->taint->xss = false;
                $this->taint->value = str_replace("_XSS", "", $this->taint->value);
            } else if (in_array($funcName, $SECURING_SQL)) {
                $taintTraverser = new PhpParser\NodeTraverser;
                $taintVisitor = new BodyVisitor();
                $taintVisitor->setDependencies($this->dependencies);
                $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                $taintTraverser->addVisitor($taintVisitor);

                $args = $node->args;
                foreach ($args as $nr => $arg) {
                    $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                    foreach ($varValueConfigurations as $varValueConfiguration) {
                        $taintVisitor->setVScope($varValueConfiguration);
                        $taintTraverser->traverse(array($arg->value));
                        $this->taint = $taintVisitor->getTaint();
                    }
                }
                if(strpos(end($this->dependencies), "if") !== false || 
                    strpos(end($this->dependencies), "elseif") !== false ||
                    strpos(end($this->dependencies), "else") !== false ||
                    strpos(end($this->dependencies), "case") !== false ){
                    $this->taint->possible = true;
                }
                $this->taint->sql = false; //$oldTaint->sql;
                $this->taint->value = str_replace("_SQL", "", $this->taint->value);
            } else if (in_array($funcName, $SECURING_ALL)) {
                $taintTraverser = new PhpParser\NodeTraverser;
                $taintVisitor = new BodyVisitor();
                $taintVisitor->setFileName($this->fileName);
                $taintVisitor->setDependencies($this->dependencies);
                $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                $taintTraverser->addVisitor($taintVisitor);

                $args = $node->args;
                foreach ($args as $nr => $arg) {
                    $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                    foreach ($varValueConfigurations as $varValueConfiguration) {
                        $taintVisitor->setVScope($varValueConfiguration);
                        $taintTraverser->traverse(array($arg->value));
                        $this->taint = $taintVisitor->getTaint();
                    }
                }
                if ($this->taint instanceof VariableValue) {
                    if(strpos(end($this->dependencies), "if") !== false || 
                        strpos(end($this->dependencies), "elseif") !== false ||
                        strpos(end($this->dependencies), "else") !== false ||
                        strpos(end($this->dependencies), "case") !== false ){
                        $this->taint->possible = true;
                    }
                    $this->taint->xss = false; //$oldTaint->xss;
                    $this->taint->sql = false; //$oldTaint->sql;
                    $this->taint->fi = false; //$oldTaint->sql;
                    $this->taint->value = str_replace("_SQL", "", $this->taint->value);
                    $this->taint->value = str_replace("_XSS", "", $this->taint->value);
                    $this->taint->value = str_replace("_FI", "", $this->taint->value);
                } else {
                    $this->taint = new VariableValue();
                }
            } else if (in_array($funcName, $INSECURING_USERINPUT)) {
                $taintTraverser = new PhpParser\NodeTraverser;
                $taintVisitor = new BodyVisitor();
                $taintVisitor->setFileName($this->fileName);
                $taintVisitor->setDependencies($this->dependencies);
                $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                $taintTraverser->addVisitor($taintVisitor);

                $args = $node->args;
                foreach ($args as $nr => $arg) {
                    $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                    foreach ($varValueConfigurations as $varValueConfiguration) {
                        $taintVisitor->setVScope($varValueConfiguration);
                        $taintTraverser->traverse(array($arg->value));
                        $this->taint = $taintVisitor->getTaint();
                    }
                }
                if ($this->taint->userInput) {
                    $this->taint->xss = true;
                    $this->taint->sql = true;
                    $this->taint->fi = true;
                    $this->taint->value = str_replace("{USERINPUT", "{USERINPUT_XSS", $this->taint->value);
                    $this->taint->value = str_replace("{USERINPUT", "{USERINPUT_SQL", $this->taint->value);
                    $this->taint->value = str_replace("{USERINPUT", "{USERINPUT_FI", $this->taint->value);
                }
            } elseif (isset($functions[$funcName])) {
                $function = $functions[$funcName];

                $this->taint = new VariableValue();
                $this->taint->userInput = false;
                $this->taint->xss = false;
                $this->taint->sql = false;
                $this->taint->fi = false;
                if (count($function->returnAlwaysVulnerable) > 0) {
                    foreach ($function->returnAlwaysVulnerable as $vuln) {
                        if ($vuln->xss) {
                            $this->taint->xss = true;
                            $this->taint->userInput = true;

                        }
                        if ($vuln->sql) {
                            $this->taint->sql = true;
                            $this->taint->userInput = true;
                        }
                        if ($vuln->fi) {
                            $this->taint->fi = true;
                            $this->taint->userInput = true;
                        }
                        if ($vuln->xss || $vuln->sql || $vuln->fi) {
                            $this->taint->flowpath = array_merge($this->taint->flowpath, $vuln->flowpath);
                            $this->taint->dependencies = array_merge($this->taint->dependencies, $vuln->dependencies);
                        }
                    }
                }
                if (count($function->alwaysVulnerable) > 0) {

                    foreach ($function->alwaysVulnerable as $toCloneVuln) {
                        $vuln = clone $toCloneVuln;
                        $vuln->flowpath = array_merge($vuln->flowpath, array(printNode($node)));
                        $vuln->dependencies = array_merge($vuln->dependencies, $this->dependencies);
                        $this->vulnerabilities->add($vuln);
                    }
                }

                if (count($function->globalVulnerable) > 0) {
                    foreach ($function->globalVulnerable as $global => $vulns) {
                        $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                        foreach ($varValueConfigurations as $varValueConfiguration) {
                            $tmpTaint = $varValueConfiguration->getVariableValue($global);
                            if ($tmpTaint !== null) {
                                foreach ($vulns as $vuln) {
                                    if ($tmpTaint->xss && $vuln->xss ||
                                        $tmpTaint->sql && $vuln->sql ||
                                        $tmpTaint->fi && $vuln->fi
                                    ) {
                                        $vuln->flowpath = array_merge($vuln->flowpath, array(printNode($node)), $tmpTaint->flowpath);
                                        $vuln->dependencies = array_merge($vuln->dependencies, $tmpTaint->dependencies);
                                        $this->vulnerabilities->add($vuln);
                                    }
                                }
                            }
                        }
                    }
                }
                if (count($function->returnGlobalVulnerable) > 0) {
                    foreach ($function->returnGlobalVulnerable as $global => $vulns) {
                        $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                        foreach ($varValueConfigurations as $varValueConfiguration) {
                            $tmpTaint = $varValueConfiguration->getVariableValue($global);
                            if ($tmpTaint !== null) {
                                foreach ($vulns as $vuln) {
                                    if ($tmpTaint->xss && $vuln->xss) {
                                        $this->taint->xss = true;
                                        $this->taint->userInput = true;
                                    }

                                    if ($tmpTaint->sql && $vuln->sql) {
                                        $this->taint->sql = true;
                                        $this->taint->userInput = true;
                                    }
                                    if ($tmpTaint->fi && $vuln->fi) {
                                        $this->taint->fi = true;
                                        $this->taint->userInput = true;
                                    }

                                    if (($tmpTaint->xss && $vuln->xss) || ($tmpTaint->sql && $vuln->sql) || ($tmpTaint->fi && $vuln->fi)) {
                                        $this->taint->flowpath = array_merge($this->taint->flowpath, $vuln->flowpath, $tmpTaint->flowpath);
                                        $this->taint->dependencies = array_merge($this->taint->dependencies, $vuln->dependencies, $tmpTaint->dependencies);
                                    }
                                }
                            }
                        }
                    }
                }

                if (count($function->globalSideEffectAlways) > 0) {
                    $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                    foreach ($varValueConfigurations as $varValueConfiguration) {
                        foreach ($function->globalSideEffectAlways as $global => $taint) {
                            $varValueConfiguration->setVariableValue($taint, $global);
                        }
                    }
                }

                if (count($function->vulnerableParameters) > 0 ||
                    count($function->returnVulnerableParameters) > 0 ||
                    count($function->globalSideEffectParameter) > 0
                ) {

                    $taintTraverser = new PhpParser\NodeTraverser;
                    $taintVisitor = new BodyVisitor();
                    $taintVisitor->setDependencies($this->dependencies);
                    $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                    $taintTraverser->addVisitor($taintVisitor);

                    $args = $node->args;
                    foreach ($args as $nr => $arg) {
                        $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                        foreach ($varValueConfigurations as $varValueConfiguration) {
                            $taintVisitor->setVScope($varValueConfiguration);
                            $taintTraverser->traverse(array($arg->value));
                            $taintInfo = $taintVisitor->getTaint();
                            if (isset($function->vulnerableParameters[$nr])) {
                                foreach ($function->vulnerableParameters[$nr] as $vulnParm) {
                                    if (($taintInfo->xss && $vulnParm->xss) || ($taintInfo->sql && $vulnParm->sql)) {
                                        $vulnParm->flowpath = array_merge($vulnParm->flowpath, array(printNode($node)), $taintInfo->flowpath);
                                        $vulnParm->dependencies = array_merge($vulnParm->dependencies, $taintInfo->dependencies);
                                        $this->vulnerabilities->add($vulnParm);
                                    }
                                    elseif ($vulnParm->sql && $taintInfo->userInput) {
                                        if (substr($taintInfo, 0, 1) !== "{" &&
                                            substr($taintInfo, -1) !== "}" &&
                                            preg_match_all("/(.*){USERINPUT[_XSQL]+}/mUs", $taintInfo->value, $matches) > 0
                                        ) {
                                            $acc = 0;
                                            foreach ($matches[1] as $match) {
                                                $acc += substr_count($match, "'");
                                                $acc += substr_count($match, '"');
                                                if ($acc % 2 == 0) {
                                                    array_unshift($taintInfo->flowpath, printNode($node));

                                                    $taintInfo->dependencies = array_merge($this->dependencies, $taintInfo->dependencies);

                                                    $vulnerability = new VulnerabilityDescription();
                                                    $vulnerability->sql = true;
                                                    $vulnerability->flowpath = $taintInfo->flowpath;
                                                    $vulnerability->dependencies = $taintInfo->dependencies;
                                                    $vulnerability->description = "SQL VULNERABILITY FOUND AT mysql_query WITH MISSING QUOTING IN FILE " . $node->getAttribute("fileName") . " LINE " . $node->getLine();

                                                    $this->vulnerabilities->add($vulnerability);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            if (isset($function->returnVulnerableParameters[$nr])) {
                                foreach ($function->returnVulnerableParameters[$nr] as $vulnParm) {
                                    if ($taintInfo->xss && $vulnParm->xss) {
                                        $this->taint->xss = true;
                                        $this->taint->userInput = true;
                                    }

                                    if ($taintInfo->sql && $vulnParm->sql) {
                                        $this->taint->sql = true;
                                        $this->taint->userInput = true;
                                    }

                                    if ($taintInfo->fi && $vulnParm->fi) {
                                        $this->taint->fi = true;
                                        $this->taint->userInput = true;
                                    }

                                    if (($taintInfo->xss && $vulnParm->xss) || ($taintInfo->sql && $vulnParm->sql) || ($taintInfo->fi && $vulnParm->fi)) {
                                        $this->taint->flowpath = array_merge($this->taint->flowpath, $taintInfo->flowpath, $vulnParm->flowpath);
                                        $this->taint->dependencies = array_merge($this->taint->dependencies, $vulnParm->dependencies, $taintInfo->dependencies);
                                    }
                                }
                            }

                            if (isset($function->globalSideEffectParameter[$nr])) {
                                foreach ($function->globalSideEffectParameter[$nr] as $global => $parmTaint) {
                                    if ($taintInfo->xss || $taintInfo->sql || $taintInfo->userInput || $taintInfo->fi) {
                                        $varValueConfiguration->setVariableValue($parmTaint, $global);
                                        $parmTaint->flowpath = array_merge($parmTaint->flowpath, $taintInfo->flowpath, array(printNode($node)));
                                        $parmTaint->dependencies = array_merge($parmTaint->dependencies, $taintInfo->dependencies);
                                    }
                                }
                            }
                        }
                    }

                }
            } else if ($funcName == "dirname") {
                $taintTraverser = new PhpParser\NodeTraverser;
                $taintVisitor = new BodyVisitor();
                $taintVisitor->setDependencies($this->dependencies);
                $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                $taintTraverser->addVisitor($taintVisitor);

                $args = $node->args;
                $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                foreach ($varValueConfigurations as $varValueConfiguration) {
                    $taintVisitor->setVScope($varValueConfiguration);
                    $taintTraverser->traverse(array($args[0]->value));
                    $taintInfo = $taintVisitor->getTaint();
                    $this->taint->value = dirname($taintInfo->value);
                }
            } else if ($funcName == "array_keys") {
                $taintTraverser = new PhpParser\NodeTraverser;
                $taintVisitor = new BodyVisitor();
                $taintVisitor->setVScope($this->vScope);
                $taintVisitor->setFileName($this->fileName);
                $taintVisitor->setDependencies($this->dependencies);
                $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                $taintTraverser->addVisitor($taintVisitor);

                $args = $node->args;
                $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                foreach ($varValueConfigurations as $varValueConfiguration) {
                    $taintVisitor->setVScope($varValueConfiguration);
                    $taintTraverser->traverse(array($args[0]->value));
                    $taintInfo = $taintVisitor->getTaint();


                    if (!is_array($taintInfo)) {
                        $taintInfo = array();
                    }
                    $array = array();
                    foreach (array_keys($taintInfo) as $val) {
                        $tmp = new VariableValue(false);
                        $tmp->value = $val;
                        // if(is_array($taintInfo[$val])){
                        //     echo(var_dump($node));
                        //     die(var_dump($taintInfo[$val]));
                        // }
                        $tmp->flowpath = $taintInfo[$val]->flowpath;
                        $tmp->dependencies = $taintInfo[$val]->dependencies;
                        $array[] = $tmp;
                    }
                    $this->taint = $array;
                }
            } else if ($funcName == "array_merge") {
                $taintTraverser = new PhpParser\NodeTraverser;
                $taintVisitor = new BodyVisitor();
                $taintVisitor->setVScope($this->vScope);
                $taintVisitor->setFileName($this->fileName);
                $taintVisitor->setDependencies($this->dependencies);
                $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                $taintTraverser->addVisitor($taintVisitor);

                $args = $node->args;
                $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                foreach ($varValueConfigurations as $varValueConfiguration) {
                    $taintVisitor->setVScope($varValueConfiguration);
                    $res = array();
                    foreach ($args as $arg) {
                        $taintTraverser->traverse(array($arg->value));
                        $taintInfo = $taintVisitor->getTaint();


                        if (!is_array($taintInfo)) {
                            $res[] = $taintInfo;
                        } else {
                            $res = array_merge($res, $taintInfo);
                        }
                    }
                    $this->taint = $res;
                }
            } else if ($funcName == "explode") {
                $taintTraverser = new PhpParser\NodeTraverser;
                $taintVisitor = new BodyVisitor();
                $taintVisitor->setVScope($this->vScope);
                $taintVisitor->setFileName($this->fileName);
                $taintVisitor->setDependencies($this->dependencies);
                $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                $taintTraverser->addVisitor($taintVisitor);

                $args = $node->args;
                $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                foreach ($varValueConfigurations as $varValueConfiguration) {
                    $taintVisitor->setVScope($varValueConfiguration);

                    $taintTraverser->traverse(array($args[1]->value));
                    $taintInfo = $taintVisitor->getTaint();

                    $res = array(clone $taintInfo, clone $taintInfo, clone $taintInfo, clone $taintInfo, clone $taintInfo, clone $taintInfo, clone $taintInfo, clone $taintInfo);

                    $this->taint = $res;
                }
            } else if ($funcName == "define") {
                $args = $node->args;
                if(count($args) == 2){
                    $target = $this->vScope;
                    while ($target->parentScope !== null) {
                        $target = $target->parentScope;
                    }
                    $taintTraverser = new PhpParser\NodeTraverser;
                    $taintVisitor = new BodyVisitor();
                    $taintVisitor->setVScope($this->vScope);
                    $taintVisitor->setFileName($this->fileName);
                    $taintVisitor->setDependencies($this->dependencies);
                    $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                    $taintTraverser->addVisitor($taintVisitor);

                    //die(var_dump($args));
                    $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                    $taintVisitor->setVScope($varValueConfigurations[0]);
                    $taintTraverser->traverse(array($args[0]->value));
                    $varName = VAR_REP_CONST . $taintVisitor->getTaint()->value;

                    $taintTraverser->traverse(array($args[1]->value));
                    //echo(var_dump($node));
                    $taintInfo = $taintVisitor->getTaint();
                    $target->setVariableValue($taintInfo, $varName);
                    //die(var_dump($target));
                }
            } else if ($funcName == "mysql_query" || $funcName == "mysqli_query") {
                $taintTraverser = new PhpParser\NodeTraverser;
                $taintVisitor = new BodyVisitor();
                $taintVisitor->setVScope($this->vScope);
                $taintVisitor->setFileName($this->fileName);
                $taintVisitor->setDependencies($this->dependencies);
                $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                $taintTraverser->addVisitor($taintVisitor);

                $args = $node->args;
                $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                foreach ($varValueConfigurations as $varValueConfiguration) {
                    $taintVisitor->setVScope($varValueConfiguration);
                    if($funcName == "mysqli_query" && count($args) == 2){
                        //mysqli_query with connection object
                        $taintTraverser->traverse(array($args[1]->value));
                    }else{
                        $taintTraverser->traverse(array($args[0]->value));
                    }
                    $taintInfo = $taintVisitor->getTaint();
                    if ($taintInfo->sql) {
                        array_unshift($taintInfo->flowpath, printNode($node));

                        $taintInfo->dependencies = array_merge($this->dependencies, $taintInfo->dependencies);

                        $vulnerability = new VulnerabilityDescription();
                        $vulnerability->sql = true;
                        $vulnerability->flowpath = $taintInfo->flowpath;
                        $vulnerability->dependencies = $taintInfo->dependencies;
                        $vulnerability->description = "SQL VULNERABILITY FOUND AT ". $funcName ." IN FILE " . $node->getAttribute("fileName") . " LINE " . $node->getLine();

                        $this->vulnerabilities->add($vulnerability);
                    } else if ($taintInfo->userInput) {
                        if (preg_match_all("/(.*){USERINPUT[_XSQL]+}/mUs", $taintInfo->value, $matches) > 0) {
                            $acc = 0;
                            foreach ($matches[1] as $match) {
                                $acc += substr_count($match, "'");
                                $acc += substr_count($match, '"');
                                if ($acc % 2 == 0) {
                                    array_unshift($taintInfo->flowpath, printNode($node));

                                    $taintInfo->dependencies = array_merge($this->dependencies, $taintInfo->dependencies);

                                    $vulnerability = new VulnerabilityDescription();
                                    $vulnerability->sql = true;
                                    $vulnerability->flowpath = $taintInfo->flowpath;
                                    $vulnerability->dependencies = $taintInfo->dependencies;
                                    $vulnerability->description = "SQL VULNERABILITY FOUND AT ". $funcName ." WITH MISSING QUOTING IN FILE " . $node->getAttribute("fileName") . " LINE " . $node->getLine();

                                    $this->vulnerabilities->add($vulnerability);
                                }
                            }
                        }
                    }

                }
            } else if (in_array($funcName, array_keys($XSS_SINKS))) {
                $taintTraverser = new PhpParser\NodeTraverser;
                $taintVisitor = new BodyVisitor();
                $taintVisitor->setVScope($this->vScope);
                $taintVisitor->setFileName($this->fileName);
                $taintVisitor->setDependencies($this->dependencies);
                $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                $taintTraverser->addVisitor($taintVisitor);

                $argPos = $XSS_SINKS[$funcName];
                $args = $node->args;
                $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                foreach ($varValueConfigurations as $varValueConfiguration) {
                    $taintVisitor->setVScope($varValueConfiguration);
                    $taintInfo = null;
                    if(is_array($argPos)){
                        $taintInfos = array(); 
                        foreach ($argPos as $a_pos) {
                            if($args[$a_pos] !== NULL){
                                $taintTraverser->traverse(array($args[$a_pos]->value));
                                $tmpTaint = $taintVisitor->getTaint();
                                $tmpTaint = squeezeArrayTaints($tmpTaint);
                                array_push($taintInfos, $tmpTaint);
                            }
                        }
                        $taintInfo = squeezeArrayTaints($taintInfos);
                    }elseif($argPos == -1){
                        //all arguments
                        $taintInfos = array(); 
                        foreach ($args as $arg) {
                            if($arg !== NULL){
                                $taintTraverser->traverse(array($arg->value));
                                $tmpTaint = $taintVisitor->getTaint();
                                $tmpTaint = squeezeArrayTaints($tmpTaint);
                                array_push($taintInfos, $tmpTaint);
                            }
                        }
                        $taintInfo = squeezeArrayTaints($taintInfos);
                    }
                     // If there is xss present, add the vulnerability
                     if ($taintInfo !== NULL && ($taintInfo->xss || strpos($taintInfo->value, "_XSS") !== false)) {
                        array_unshift($taintInfo->flowpath, printNode($node));
                        $taintInfo->dependencies = array_merge($this->dependencies, $taintInfo->dependencies);

                        $vulnerability = new VulnerabilityDescription();
                        $vulnerability->xss = true;
                        $vulnerability->flowpath = $taintInfo->flowpath;
                        $vulnerability->dependencies = $taintInfo->dependencies;
                        $vulnerability->description = "XSS VULNERABILITY FOUND AT echo IN FILE " . $node->getAttribute("fileName") . " LINE " . $node->getLine();

                        $this->vulnerabilities->add($vulnerability);
                    }
                }
            }else {
                $taintTraverser = new PhpParser\NodeTraverser;
                $taintVisitor = new BodyVisitor();
                $taintVisitor->setVScope($this->vScope);
                $taintVisitor->setFileName($this->fileName);
                $taintVisitor->setDependencies($this->dependencies);
                $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                $taintTraverser->addVisitor($taintVisitor);

                $args = $node->args;
                if (count($args) > 0) {
                    $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                    foreach ($varValueConfigurations as $varValueConfiguration) {
                        $taintVisitor->setVScope($varValueConfiguration);
                        //echo(count($args) . "\n");
                        foreach ($args as $arg) {
                            $taintTraverser->traverse(array($arg->value));
                            //$tmptaint = $taintVisitor->getTaint();
                            //echo(var_dump($tmptaint));
                        }
                        //echo(count($args). "\n");
                    }
                }
                $tmptaint = $taintVisitor->getTaint();
                //die(var_dump($this->taint));
                if($tmptaint){
                    if(is_array($tmptaint)){
                        //echo var_dump($node) . "\n";
                        //echo(var_dump($tmptaint)) . "\n";
                        //$taintKeys
                        $som = prepareMultipleTaintInfo($tmptaint);
                        //echo(var_dump($som)) . "\n";
                        if($this->taint){
                            if(is_array($this->taint)){
                                $this->taint = array_merge($this->taint, $som);
                            }else{
                                $this->taint = array_merge(array($this->taint), $som);
                            }
                        }else{
                            $this->taint = $som;
                        }
                    }
                    // if(is_array($tmptaint) || $tmptaint->path){
                    //     //echo(var_dump($node));
                    //     echo(var_dump($tmptaint)) . "\n";
                    //     //echo count($tmptaint) . "\n";
                    //     //Comes out as an array on occassions yet to understand; Pick the last element as a buggy fix
                    //     if($tmptaint['path'] !== NULL){
                    //         $tmptaint = $tmptaint['path'];
                    //     }elseif($tmptaint[0]->path !== NULL){
                    //         $tmptaint = $tmptaint[0]->path;
                    //     }else{
                    //         $tmptaint = $tmptaint[count($tmptaint) - 1];
                    //     }
                    // }


                    // $this->taint->userInput = $this->taint->userInput || $tmptaint->userInput;
                    // $this->taint->xss = $this->taint->xss || $tmptaint->xss;
                    // $this->taint->sql = $this->taint->sql || $tmptaint->sql;
                    // if ($this->taint->userInput) {
                    //     $this->taint->value = "{USERINPUT_".($this->taint->xss?"_XSS":"").($this->taint->sql?"_SQL":"")."}";
                    // }
                }
            }

            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;

        }
        elseif ($node instanceof PhpParser\Node\Expr\MethodCall) {
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor();
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
            $taintVisitor->setVScope($this->vScope);
            $taintVisitor->setFileName($this->fileName);
            $taintTraverser->addVisitor($taintVisitor);
            $assignArray = $this->findVarNameAndDim($node->var, $taintTraverser, $taintVisitor);
            $class = call_user_func_array(array($this->vScope, 'getVariableValue'), $assignArray);

            if (!($class instanceof ClassDescription)) {
                return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
            }
            $method = $class->getMethod($node->name);

            if ($method !== null) {

                $args = $node->args;

                if (!($this->taint instanceof VariableValue)) {
                    $this->taint = new VariableValue();
                }

                $this->taint->userInput = false;
                $this->taint->xss = false;
                $this->taint->sql = false;
                if (count($method->returnAlwaysVulnerable) > 0) {
                    foreach ($method->returnAlwaysVulnerable as $vuln) {
                        if ($vuln->xss) {
                            $this->taint->xss = true;
                            $this->taint->userInput = true;
                        }
                        if ($vuln->sql) {
                            $this->taint->sql = true;
                            $this->taint->userInput = true;
                        }
                        if ($vuln->xss || $vuln->sql) {
                            $this->taint->flowpath = array_merge($this->taint->flowpath, $vuln->flowpath);
                            $this->taint->dependencies = array_merge($this->taint->dependencies, $vuln->dependencies);
                        }
                    }
                }
                if (count($method->alwaysVulnerable) > 0) {
                    $this->vulnerabilities->add($method->alwaysVulnerable);
                }

                if (count($method->vulnerableParameters) > 0 || count($method->returnVulnerableParameters) > 0) {
                    $taintTraverser = new PhpParser\NodeTraverser;
                    $taintVisitor = new BodyVisitor();
                    $taintVisitor->setFileName($this->fileName);
                    $taintVisitor->setDependencies($this->dependencies);
                    $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                    $taintTraverser->addVisitor($taintVisitor);
                    foreach ($args as $nr => $arg) {
                        $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                        foreach ($varValueConfigurations as $varValueConfiguration) {
                            $taintVisitor->setVScope($varValueConfiguration);
                            $taintTraverser->traverse(array($arg->value));
                            $taintInfo = $taintVisitor->getTaint();
                            if (isset($method->vulnerableParameters[$nr])) {
                                foreach ($method->vulnerableParameters[$nr] as $vulnParm) {
                                    if (($taintInfo->xss && $vulnParm->xss) || ($taintInfo->sql && $vulnParm->sql)) {
                                        $vulnParm->flowpath = array_merge($vulnParm->flowpath, array(printNode($node)), $taintInfo->flowpath);
                                        $vulnParm->dependencies = array_merge($vulnParm->dependencies, $taintInfo->dependencies);
                                        $this->vulnerabilities->add($vulnParm);
                                    }
                                    elseif ($vulnParm->sql && $taintInfo->userInput) {
                                        if (substr($taintInfo, 0, 1) !== "{" &&
                                            substr($taintInfo, -1) !== "}" &&
                                            preg_match_all("/(.*){USERINPUT[_XSQL]+}/mUs", $taintInfo->value, $matches) > 0
                                        ) {
                                            $acc = 0;
                                            foreach ($matches[1] as $match) {
                                                $acc += substr_count($match, "'");
                                                $acc += substr_count($match, '"');
                                                if ($acc % 2 == 0) {
                                                    array_unshift($taintInfo->flowpath, printNode($node));

                                                    $taintInfo->dependencies = array_merge($this->dependencies, $taintInfo->dependencies);

                                                    $vulnerability = new VulnerabilityDescription();
                                                    $vulnerability->sql = true;
                                                    $vulnerability->flowpath = $taintInfo->flowpath;
                                                    $vulnerability->dependencies = $taintInfo->dependencies;
                                                    $vulnerability->description = "SQL VULNERABILITY FOUND AT mysql_query WITH MISSING QUOTING IN FILE " . $node->getAttribute("fileName") . " LINE " . $node->getLine();

                                                    $this->vulnerabilities->add($vulnerability);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            if (isset($method->returnVulnerableParameters[$nr])) {

                                foreach ($method->returnVulnerableParameters[$nr] as $vulnParm) {
                                    if ($taintInfo->xss && $vulnParm->xss) {
                                        $this->taint->xss = true;
                                        $this->taint->userInput = true;
                                    }

                                    if ($taintInfo->sql && $vulnParm->sql) {
                                        $this->taint->sql = true;
                                        $this->taint->userInput = true;
                                    }

                                    if (($taintInfo->xss && $vulnParm->xss) || ($taintInfo->sql && $vulnParm->sql)) {
                                        $this->taint->flowpath = array_merge($this->taint->flowpath, $taintInfo->flowpath, $vulnParm->flowpath);
                                        $this->taint->dependencies = array_merge($this->taint->dependencies, $vulnParm->dependencies, $taintInfo->dependencies);
                                    }
                                }
                            }
                        }
                    }

                }

                if (count($method->vulnerableProperties) > 0 || count($method->returnVulnerableProperties) > 0) {

                    foreach ($method->vulnerableProperties as $vulnPropName => $vulnPropValues) {
                        $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                        foreach ($varValueConfigurations as $varValueConfiguration) {
                            $taintInfo = $varValueConfiguration->getVariableValue($node->var->name, $vulnPropName);
                            foreach ($vulnPropValues as $vulnProp => $vulnPropValue) {
                                if (($taintInfo !== null) && (($taintInfo->xss && $vulnPropValue->xss) || ($taintInfo->sql && $vulnPropValue->sql))) {
                                    $vulnParm->flowpath = array_merge($vulnParm->flowpath, array(printNode($node)), $taintInfo->flowpath);
                                    $vulnParm->dependencies = array_merge($vulnParm->dependencies, $taintInfo->dependencies);
                                    $this->vulnerabilities->add($vulnPropValue);
                                }
                            }
                        }
                    }

                    foreach ($method->returnVulnerableProperties as $vulnPropName => $vulnPropValues) {
                        $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                        foreach ($varValueConfigurations as $varValueConfiguration) {
                            $taintInfo = $varValueConfiguration->getVariableValue($node->var->name, $vulnPropName);
                            if ($taintInfo != null) {
                                foreach ($vulnPropValues as $vulnProp => $vulnPropValue) {
                                    if ($taintInfo->xss && $vulnPropValue->xss) {
                                        $this->taint->xss = true;
                                        $this->taint->userInput = true;
                                    }
                                    if ($taintInfo->sql && $vulnPropValue->sql) {
                                        $this->taint->sql = true;
                                        $this->taint->userInput = true;
                                    }
                                    if (($taintInfo->xss && $vulnPropValue->xss) || ($taintInfo->sql && $vulnPropValue->sql)) {
                                        $this->taint->flowpath = array_merge($this->taint->flowpath, $taintInfo->flowpath, $vulnPropValue->flowpath);
                                        $this->taint->dependencies = array_merge($this->taint->dependencies, $vulnPropValue->dependencies, $taintInfo->dependencies);
                                    }
                                }
                            }
                        }
                    }
                }

                if (count($method->propertyVulnerableParameters) > 0) {
                    $taintTraverser = new PhpParser\NodeTraverser;
                    $taintVisitor = new BodyVisitor();
                    $taintVisitor->setFileName($this->fileName);
                    $taintVisitor->setDependencies($this->dependencies);
                    $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                    $taintTraverser->addVisitor($taintVisitor);
                    foreach ($method->propertyVulnerableParameters as $property => $sources) {
                        $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                        foreach ($varValueConfigurations as $varValueConfiguration) {
                            $taintVisitor->setVScope($varValueConfiguration);
                            $propTaintInfo = new VariableValue();
                            foreach ($sources as $paramNr => $taintInfo) {
                                $taintTraverser->traverse(array($args[$paramNr]->value));
                                $taintInfo = $taintVisitor->getTaint();
                                if ($taintInfo != null) {

                                    if ($taintInfo->userInput) {
                                        $propTaintInfo->userInput = true;
                                    }
                                    if ($taintInfo->xss) {
                                        $propTaintInfo->xss = true;
                                    }
                                    if ($taintInfo->sql) {
                                        $propTaintInfo->sql = true;
                                    }
                                    if ($taintInfo->userInput || $taintInfo->xss || $taintInfo->sql) {
                                        $propTaintInfo->dependencies = array_merge($propTaintInfo->dependencies, $taintInfo->dependencies);
                                        $propTaintInfo->flowpath = array_merge($propTaintInfo->flowpath, array(printNode($node)), $taintInfo->flowpath);

                                    }
                                }
                            }
                            $varValueConfiguration->setVariableValue($propTaintInfo, $node->var->name, $property);
                        }
                    }
                }
                if (count($method->propertyVulnerable) > 0) {
                    $taintTraverser = new PhpParser\NodeTraverser;
                    $taintVisitor = new BodyVisitor();
                    $taintVisitor->setDependencies($this->dependencies);
                    $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                    $taintTraverser->addVisitor($taintVisitor);
                    foreach ($method->propertyVulnerable as $property => $taintInfo) {
                        $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                        foreach ($varValueConfigurations as $varValueConfiguration) {
                            $varValueConfiguration->setVariableValue($taintInfo, $node->var->name, $property);
                        }
                    }
                }

            }
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;

        }
        elseif ($node instanceof PhpParser\Node\Expr\StaticCall) {
            // Følgende er hurtigt lavet op til aflevering, måske der er problemer med sideeffect osv. det bør man nok kigge på

            $class = ClassStorage::getClass($node->class->parts[0]);

            if (!($class instanceof ClassDescription)) {
                return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
            }
            $method = $class->getMethod($node->name);

            if ($method !== null) {

                $args = $node->args;

                if (!($this->taint instanceof VariableValue)) {
                    $this->taint = new VariableValue();
                }

                $this->taint->userInput = false;
                $this->taint->xss = false;
                $this->taint->sql = false;
                if (count($method->returnAlwaysVulnerable) > 0) {
                    foreach ($method->returnAlwaysVulnerable as $vuln) {
                        if ($vuln->xss) {
                            $this->taint->xss = true;
                            $this->taint->userInput = true;
                        }
                        if ($vuln->sql) {
                            $this->taint->sql = true;
                            $this->taint->userInput = true;
                        }
                        if ($vuln->xss || $vuln->sql) {
                            $this->taint->flowpath = array_merge($this->taint->flowpath, $vuln->flowpath);
                            $this->taint->dependencies = array_merge($this->taint->dependencies, $vuln->dependencies);
                        }
                    }
                }
                if (count($method->alwaysVulnerable) > 0) {
                    $this->vulnerabilities->add($method->alwaysVulnerable);
                }

                if (count($method->vulnerableParameters) > 0 || count($method->returnVulnerableParameters) > 0) {
                    $taintTraverser = new PhpParser\NodeTraverser;
                    $taintVisitor = new BodyVisitor();
                    $taintVisitor->setFileName($this->fileName);
                    $taintVisitor->setDependencies($this->dependencies);
                    $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                    $taintTraverser->addVisitor($taintVisitor);
                    foreach ($args as $nr => $arg) {
                        $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                        foreach ($varValueConfigurations as $varValueConfiguration) {
                            $taintVisitor->setVScope($varValueConfiguration);
                            $taintTraverser->traverse(array($arg->value));
                            $taintInfo = $taintVisitor->getTaint();
                            if (isset($method->vulnerableParameters[$nr])) {
                                foreach ($method->vulnerableParameters[$nr] as $vulnParm) {
                                    if (($taintInfo->xss && $vulnParm->xss) || ($taintInfo->sql && $vulnParm->sql)) {
                                        $vulnParm->flowpath = array_merge($vulnParm->flowpath, array(printNode($node)), $taintInfo->flowpath);
                                        $vulnParm->dependencies = array_merge($vulnParm->dependencies, $taintInfo->dependencies);
                                        $this->vulnerabilities->add($vulnParm);
                                    }
                                    elseif ($vulnParm->sql && $taintInfo->userInput) {
                                        if (substr($taintInfo, 0, 1) !== "{" &&
                                            substr($taintInfo, -1) !== "}" &&
                                            preg_match_all("/(.*){USERINPUT[_XSQL]+}/mUs", $taintInfo->value, $matches) > 0
                                        ) {
                                            $acc = 0;
                                            foreach ($matches[1] as $match) {
                                                $acc += substr_count($match, "'");
                                                $acc += substr_count($match, '"');
                                                if ($acc % 2 == 0) {
                                                    array_unshift($taintInfo->flowpath, printNode($node));

                                                    $taintInfo->dependencies = array_merge($this->dependencies, $taintInfo->dependencies);

                                                    $vulnerability = new VulnerabilityDescription();
                                                    $vulnerability->sql = true;
                                                    $vulnerability->flowpath = $taintInfo->flowpath;
                                                    $vulnerability->dependencies = $taintInfo->dependencies;
                                                    $vulnerability->description = "SQL VULNERABILITY FOUND AT mysql_query WITH MISSING QUOTING IN FILE " . $node->getAttribute("fileName") . " LINE " . $node->getLine();

                                                    $this->vulnerabilities->add($vulnerability);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            if (isset($method->returnVulnerableParameters[$nr])) {

                                foreach ($method->returnVulnerableParameters[$nr] as $vulnParm) {
                                    if ($taintInfo->xss && $vulnParm->xss) {
                                        $this->taint->xss = true;
                                        $this->taint->userInput = true;
                                    }

                                    if ($taintInfo->sql && $vulnParm->sql) {
                                        $this->taint->sql = true;
                                        $this->taint->userInput = true;
                                    }

                                    if (($taintInfo->xss && $vulnParm->xss) || ($taintInfo->sql && $vulnParm->sql)) {
                                        $this->taint->flowpath = array_merge($this->taint->flowpath, $taintInfo->flowpath, $vulnParm->flowpath);
                                        $this->taint->dependencies = array_merge($this->taint->dependencies, $vulnParm->dependencies, $taintInfo->dependencies);
                                    }
                                }
                            }
                        }
                    }

                }

                if (count($method->vulnerableProperties) > 0 || count($method->returnVulnerableProperties) > 0) {

                    foreach ($method->vulnerableProperties as $vulnPropName => $vulnPropValues) {
                        $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                        foreach ($varValueConfigurations as $varValueConfiguration) {
                            $taintInfo = $varValueConfiguration->getVariableValue($node->var->name, $vulnPropName);
                            foreach ($vulnPropValues as $vulnProp => $vulnPropValue) {
                                if (($taintInfo !== null) && (($taintInfo->xss && $vulnPropValue->xss) || ($taintInfo->sql && $vulnPropValue->sql))) {
                                    $vulnParm->flowpath = array_merge($vulnParm->flowpath, array(printNode($node)), $taintInfo->flowpath);
                                    $vulnParm->dependencies = array_merge($vulnParm->dependencies, $taintInfo->dependencies);
                                    $this->vulnerabilities->add($vulnPropValue);
                                }
                            }
                        }
                    }

                    foreach ($method->returnVulnerableProperties as $vulnPropName => $vulnPropValues) {
                        $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                        foreach ($varValueConfigurations as $varValueConfiguration) {
                            $taintInfo = $varValueConfiguration->getVariableValue($node->var->name, $vulnPropName);
                            if ($taintInfo != null) {
                                foreach ($vulnPropValues as $vulnProp => $vulnPropValue) {
                                    if ($taintInfo->xss && $vulnPropValue->xss) {
                                        $this->taint->xss = true;
                                        $this->taint->userInput = true;
                                    }
                                    if ($taintInfo->sql && $vulnPropValue->sql) {
                                        $this->taint->sql = true;
                                        $this->taint->userInput = true;
                                    }
                                    if (($taintInfo->xss && $vulnPropValue->xss) || ($taintInfo->sql && $vulnPropValue->sql)) {
                                        $this->taint->flowpath = array_merge($this->taint->flowpath, $taintInfo->flowpath, $vulnPropValue->flowpath);
                                        $this->taint->dependencies = array_merge($this->taint->dependencies, $vulnPropValue->dependencies, $taintInfo->dependencies);
                                    }
                                }
                            }
                        }
                    }
                }

                if (count($method->propertyVulnerableParameters) > 0) {
                    $taintTraverser = new PhpParser\NodeTraverser;
                    $taintVisitor = new BodyVisitor();
                    $taintVisitor->setFileName($this->fileName);
                    $taintVisitor->setDependencies($this->dependencies);
                    $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
                    $taintTraverser->addVisitor($taintVisitor);
                    foreach ($method->propertyVulnerableParameters as $property => $sources) {
                        $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
                        foreach ($varValueConfigurations as $varValueConfiguration) {
                            $taintVisitor->setVScope($varValueConfiguration);
                            $propTaintInfo = new VariableValue();
                            foreach ($sources as $paramNr => $taintInfo) {
                                $taintTraverser->traverse(array($args[$paramNr]->value));
                                $taintInfo = $taintVisitor->getTaint();
                                if ($taintInfo != null) {

                                    if ($taintInfo->userInput) {
                                        $propTaintInfo->userInput = true;
                                    }
                                    if ($taintInfo->xss) {
                                        $propTaintInfo->xss = true;
                                    }
                                    if ($taintInfo->sql) {
                                        $propTaintInfo->sql = true;
                                    }
                                    if ($taintInfo->userInput || $taintInfo->xss || $taintInfo->sql) {
                                        $propTaintInfo->dependencies = array_merge($propTaintInfo->dependencies, $taintInfo->dependencies);
                                        $propTaintInfo->flowpath = array_merge($propTaintInfo->flowpath, array(printNode($node)), $taintInfo->flowpath);

                                    }
                                }
                            }
                            $varValueConfiguration->setVariableValue($propTaintInfo, $node->var->name, $property);
                        }
                    }
                }

            }
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;

        }
        elseif ($node instanceof PhpParser\Node\Stmt\Echo_ ||
            $node instanceof PhpParser\Node\Expr\Print_ ||
            $node instanceof PhpParser\Node\Expr\Exit_
        ) {
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor;
            $taintTraverser->addVisitor($taintVisitor);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);

            //echo(var_dump($node));

            $exprs = ($node instanceof PhpParser\Node\Stmt\Echo_) ? $node->exprs : array($node->expr);
            // Simulate the output for each possible scope
            $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
            //var_dump($varValueConfigurations);
            
            foreach ($varValueConfigurations as $varValueConfiguration) {
                $taintVisitor->setVScope($varValueConfiguration);

                // Echo is special as it can has multiple outputs, lets emulate each of them
                foreach ($exprs as $expr) {
                    $moreDescription = "";
                    $taintTraverser->traverse(array($expr));
                    $taintInfo = $taintVisitor->getTaint();
                    //when echo is called on a function that collects an array. e.g a_function(array())
                    if($expr instanceof PhpParser\Node\Expr\FuncCall){
                        if(is_array($taintInfo)){
                            $functionTaint = array_splice($taintInfo, 0, 1)[0];
                            if(count($taintInfo) > 1 && $functionTaint->xss){
                                $otherTaint = array_splice($taintInfo, 1, count($taintInfo) - 1);
                                foreach ($otherTaint as $taintt) {
                                    $taintInfo = $taintt;
                                    if($taintt->xss){
                                        break;
                                    }
                                }
                            }else{
                                $taintInfo = $functionTaint;
                            }
                        }
                    }else{
                        if($this->vScope->id == 0 && $expr instanceof PhpParser\Node\Expr){
                            if($expr->name !== NULL){
                                $tmpT = $taintInfo;
                                list($taintInfo, $sanitize) = $this->checkAllCodePathsAtSink($expr->name);
                                // if($node->getLine() == 92){
                                //     die(var_dump($taintInfo));
                                // }
                                if($taintInfo !== null){
                                    if($taintInfo->xss){
                                        $moreDescription = $sanitize == false ? "\n\nSANITIZATION NOT DONE ON ALL CODE PATHS" : "";
                                    }
                                }else{
                                    $taintInfo = $tmpT;
                                }
                            }
                        }
                    }

                    // If it is a class, try to call the __toString thingy
                    if ($taintInfo instanceof ClassDescription) {
                        $parser = (new PhpParser\ParserFactory)->create(PhpParser\ParserFactory::PREFER_PHP7);
                        $prettyPrinter = new PhpParser\PrettyPrinter\Standard;
                        $tostringCall = $parser->parse("<?php ".substr($prettyPrinter->prettyPrint(array($expr)),0,-1)."->__toString();");
                        $taintTraverser->traverse($tostringCall);
                        $taintInfo = $taintVisitor->getTaint();

                    }

                    // If there is xss present, add the vulnerability
                    if ($taintInfo->xss || strpos($taintInfo->value, "_XSS") !== false) {
                        array_unshift($taintInfo->flowpath, printNode($node));
                        $taintInfo->dependencies = array_merge($this->dependencies, $taintInfo->dependencies);

                        $vulnerability = new VulnerabilityDescription();
                        $vulnerability->xss = true;
                        $vulnerability->flowpath = $taintInfo->flowpath;
                        $vulnerability->dependencies = $taintInfo->dependencies;
                        $vulnerability->description = "XSS VULNERABILITY FOUND AT echo IN FILE " . $node->getAttribute("fileName") . " LINE " . $node->getLine() . $moreDescription;

                        $this->vulnerabilities->add($vulnerability);
                    }
                }
            }
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Stmt\Return_) {
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor;
            $taintTraverser->addVisitor($taintVisitor);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
            $taintVisitor->setVScope($this->vScope);
            $taintVisitor->setFileName($this->fileName);
            $taintTraverser->traverse(array($node->expr));
            $taintInfo = $taintVisitor->getTaint();
            if (($taintInfo instanceof VariableValue) && ($taintInfo->userInput || $taintInfo->xss || $taintInfo->sql || $taintInfo->fi)) {
                array_unshift($taintInfo->flowpath, printNode($node));
                $taintInfo->dependencies = array_merge($this->dependencies, $taintInfo->dependencies);

                $vulnerability = new VulnerabilityDescription();
                $vulnerability->return = true;
                $vulnerability->xss = $taintInfo->xss;
                $vulnerability->sql = $taintInfo->sql;
                $vulnerability->fi = $taintInfo->fi;

                $vulnerability->flowpath = $taintInfo->flowpath;
                $vulnerability->dependencies = $taintInfo->dependencies;
                $vulnerability->description = "RETURN VULNERABILITY FOUND AT return in FILE " . $node->getAttribute("fileName") . " LINE " . $node->getLine();

                $this->vulnerabilities->add($vulnerability);
            }
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        /*
         * Assignments
         */
        elseif ($node instanceof PhpParser\Node\Expr\Assign) {
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor;
            $taintTraverser->addVisitor($taintVisitor);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);

            $vars = array($node->var);

            $assignList = false;
            if($node->var instanceof PhpParser\Node\Expr\List_){
                $vars = $node->items;
                $assignList = true;
            }

            // Simulate for each of the possible variable scopes
            $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
            foreach ($varValueConfigurations as $varValueConfiguration) {
                $taintVisitor->setVScope($varValueConfiguration);

                foreach ($vars as $index => $var) {

                    $assignArray = $this->findVarNameAndDim($var, $taintTraverser, $taintVisitor);

                    if ($node->expr instanceof PhpParser\Node\Expr\New_) {
                        $class = ClassStorage::getClass($node->expr->class->parts[0]);
                        
                        array_unshift($assignArray, $class);
                        call_user_func_array(array($varValueConfiguration, 'setVariableValue'), $assignArray);

                    } else {
                        $taintTraverser->traverse(array($node->expr));
                        $taintInfo = $taintVisitor->getTaint();
                        appendTaintinfo($taintInfo, printNode($node), $this->dependencies);

                        if ($taintInfo instanceof VariableValue) {
                            if($assignList){
                                array_unshift($assignArray, $taintInfo);
                            }else{
                                $this->taint = clone $taintInfo;
                            }
                        }elseif($assignList){
                            array_unshift($assignArray, $taintInfo[$index]);
                        }
                        // save the infosetVariableValue
                        if ($var instanceof PhpParser\Node\Expr\StaticPropertyFetch) {
                            $className = $var->class->parts[0];
                            $propertyName = $var->name;
                            $taintInfo = $this->vScope->getVariableValue(VAR_REP_STATIC . $className, $propertyName); //????
                        } else {
                            if(!$assignList){
                                array_unshift($assignArray, $taintInfo);
                            }
                            call_user_func_array(array($varValueConfiguration, 'setVariableValue'), $assignArray);
                        }
                    }
                }
            }
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN; // remove the node, we do no want the
        }
        elseif ($node instanceof PhpParser\Node\Expr\AssignOp\Concat) {
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor();
            $taintVisitor->setVScope($this->vScope);
            $taintVisitor->setFileName($this->fileName);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
            $taintTraverser->addVisitor($taintVisitor);

            $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
            foreach ($varValueConfigurations as $varValueConfiguration) {
                $taintVisitor->setVScope($varValueConfiguration);
                $assignArray = $this->findVarNameAndDim($node->var, $taintTraverser, $taintVisitor);

                $taintTraverser->traverse(array($node->var));
                $taintInfo = $taintVisitor->getTaint();

                $taintTraverser->traverse(array($node->expr));
                $tmpTaint = $taintVisitor->getTaint();

                if(is_array($taintInfo)){
                    $taintInfo = squeezeArrayTaints($taintInfo);
                }
                if(is_array($tmpTaint)){
                    $tmpTaint = squeezeArrayTaints($tmpTaint);
                }

                if (!$taintInfo->xss && $tmpTaint->xss ||
                    !$taintInfo->sql && $tmpTaint->sql ||
                    !$taintInfo->fi && $tmpTaint->fi ||
                    !$taintInfo->userInput && $tmpTaint->userInput
                ) {
                    $taintInfo->flowpath = array_merge(array(printNode($node)), $taintInfo->flowpath, $tmpTaint->flowpath);
                    $taintInfo->dependencies = array_merge($this->dependencies, $taintInfo->dependencies, $tmpTaint->dependencies);
                }
                $taintInfo->xss = $taintInfo->xss || $tmpTaint->xss;
                $taintInfo->sql = $taintInfo->sql || $tmpTaint->sql;
                $taintInfo->fi = $taintInfo->fi || $tmpTaint->fi;
                $taintInfo->userInput = $taintInfo->userInput || $tmpTaint->userInput;
                $taintInfo->value = $taintInfo->value . $tmpTaint->value;
                //$taintInfo->flowpath = array_merge($taintInfo->flowpath,$tmpTaint->flowpath);
                //$taintInfo->dependencies = array_merge($taintInfo->dependencies,$tmpTaint->dependencies);


                array_unshift($assignArray, $taintInfo);
                call_user_func_array(array($varValueConfiguration, 'setVariableValue'), $assignArray);
            }
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Expr\AssignOp\Plus) {
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor();
            $taintVisitor->setVScope($this->vScope);
            $taintVisitor->setFileName($this->fileName);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
            $taintTraverser->addVisitor($taintVisitor);

            $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
            foreach ($varValueConfigurations as $varValueConfiguration) {
                $taintVisitor->setVScope($varValueConfiguration);
                $assignArray = $this->findVarNameAndDim($node->var, $taintTraverser, $taintVisitor);

                $taintTraverser->traverse(array($node->var));
                $taintInfo = $taintVisitor->getTaint();

                $taintTraverser->traverse(array($node->expr));
                $tmpTaint = $taintVisitor->getTaint();

                if(is_array($taintInfo)){
                    $taintInfo = squeezeArrayTaints($taintInfo);
                }
                if(is_array($tmpTaint)){
                    $tmpTaint = squeezeArrayTaints($tmpTaint);
                }

                $taintInfo->xss = $taintInfo->xss || $tmpTaint->xss;
                $taintInfo->sql = $taintInfo->sql || $tmpTaint->sql;
                $taintInfo->fi = $taintInfo->fi || $tmpTaint->fi;
                $taintInfo->userInput = $taintInfo->userInput || $tmpTaint->userInput;
                if(is_numeric($taintInfo->value) && is_numeric($tmpTaint->value)){
                    $taintInfo->value = $taintInfo->value + $tmpTaint->value;
                }else{
                    $taintInfo->value = (string)$taintInfo->value . (string)$tmpTaint->value;
                }
                $taintInfo->flowpath = array_merge($taintInfo->flowpath, $tmpTaint->flowpath);
                $taintInfo->dependencies = array_merge($taintInfo->dependencies, $tmpTaint->dependencies);


                array_unshift($assignArray, $taintInfo);
                call_user_func_array(array($varValueConfiguration, 'setVariableValue'), $assignArray);
            }
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        /**
         * Math stuff
         */
        elseif ($node instanceof PhpParser\Node\Expr\PostInc) {
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor;
            $taintTraverser->addVisitor($taintVisitor);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);

            // Simulate for each of the possible variable scopes
            $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
            foreach ($varValueConfigurations as $varValueConfiguration) {
                $taintVisitor->setVScope($varValueConfiguration);
                $assignArray = $this->findVarNameAndDim($node->var, $taintTraverser, $taintVisitor);

                $val = call_user_func_array(array($varValueConfiguration, 'getVariableValue'), $assignArray);
                if($val == NULL){
                    //Sometimes coders dont declare numeric variables
                    $val = new VariableValue();
                    $val->value = 0;
                }
                $val->value++;

                array_unshift($assignArray, $val);
                call_user_func_array(array($varValueConfiguration, 'setVariableValue'), $assignArray);
            }
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Expr\PostDec) {
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor;
            $taintTraverser->addVisitor($taintVisitor);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);

            // Simulate for each of the possible variable scopes
            $varValueConfigurations = $this->vScope->getDependencyStorage($this->dependencies);
            foreach ($varValueConfigurations as $varValueConfiguration) {
                $taintVisitor->setVScope($varValueConfiguration);
                $assignArray = $this->findVarNameAndDim($node->var, $taintTraverser, $taintVisitor);

                $val = call_user_func_array(array($varValueConfiguration, 'getVariableValue'), $assignArray);
                if($val == NULL){
                    //Sometimes coders dont declare numeric variables
                    $val = new VariableValue();
                    $val->value = 0;
                }
                $val->value--;

                array_unshift($assignArray, $val);
                call_user_func_array(array($varValueConfiguration, 'setVariableValue'), $assignArray);
            }
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Expr\BinaryOp\Div) {
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor();
            $taintVisitor->setVScope($this->vScope);
            $taintVisitor->setFileName($this->fileName);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
            $taintTraverser->addVisitor($taintVisitor);

            $taintTraverser->traverse(array($node->left));
            $leftTaint = $taintVisitor->getTaint();
            $taintTraverser->traverse(array($node->right));
            $partTaint = $taintVisitor->getTaint();

            $this->taint = new VariableValue();
            if ($partTaint->value == 0) {
                $partTaint->value = 1;
            }
            $this->taint->value = $leftTaint->value / $partTaint->value;
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Expr\BinaryOp\Mul) {
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor();
            $taintVisitor->setVScope($this->vScope);
            $taintVisitor->setFileName($this->fileName);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
            $taintTraverser->addVisitor($taintVisitor);

            $taintTraverser->traverse(array($node->left));
            $leftTaint = $taintVisitor->getTaint();
            $taintTraverser->traverse(array($node->right));
            $partTaint = $taintVisitor->getTaint();

            $this->taint = new VariableValue();
            $this->taint->value = $leftTaint->value * $partTaint->value;
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Expr\BinaryOp\Plus) {
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor();
            $taintVisitor->setVScope($this->vScope);
            $taintVisitor->setFileName($this->fileName);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
            $taintTraverser->addVisitor($taintVisitor);

            $taintTraverser->traverse(array($node->left));
            $leftTaint = $taintVisitor->getTaint();
            $taintTraverser->traverse(array($node->right));
            $partTaint = $taintVisitor->getTaint();

            $this->taint = new VariableValue();
            $this->taint->value = $leftTaint->value + $partTaint->value;
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        elseif ($node instanceof PhpParser\Node\Expr\BinaryOp\Minus) {
            $taintTraverser = new PhpParser\NodeTraverser;
            $taintVisitor = new BodyVisitor();
            $taintVisitor->setVScope($this->vScope);
            $taintVisitor->setFileName($this->fileName);
            $taintVisitor->setDependencies($this->dependencies);
            $taintVisitor->setVulnerabilityStorage($this->vulnerabilities);
            $taintTraverser->addVisitor($taintVisitor);

            $taintTraverser->traverse(array($node->left));
            $leftTaint = $taintVisitor->getTaint();
            $taintTraverser->traverse(array($node->right));
            $partTaint = $taintVisitor->getTaint();

            $this->taint = new VariableValue();
            $this->taint->value = $leftTaint->value - $partTaint->value;
            return PhpParser\NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN;
        }
        /**
         *
         */
        
        else {
            //print_r($node);
            //die();
        }
    }

    public function leaveNode(PhpParser\Node $node)
    {
        // When a if is left remove the dependencies
        if ($node instanceof PhpParser\Node\Stmt\If_ ||
            $node instanceof PhpParser\Node\Stmt\Switch_
        ) {
            array_pop($this->dependencies);
            $places = array_pop($this->ifScopes);
            // if (!self::$fullTree) {
            //     if (count($places) > 500) {
            //         echo "Clean up on " . count($places) . " subnodes, this can take some time\n";
            //         echo $node->getAttribute("fileName") . ":" . $node->getLine() . "\n";
            //     }
            //     foreach ($places as $place) {
            //         $place->cleanUp();
            //     }
            // }
            //echo(var_dump($this->vScope));
        }
        // if($this->taint && ($this->taint->userInput || $this->taint->xss || $this->taint->sql)){
        //     //echo(var_dump($node)). "\n";
        //     //echo(var_dump($this->taint)). "\n";
        // }
        
    }

    private function findVarNameAndDim($node, $taintTraverser, $taintVisitor)
    {
        if ($node instanceof PhpParser\Node\Expr\Variable) {
            if (is_object($node->name)) {
                $taintTraverser->traverse(array($node->name));
                $val = $taintVisitor->getTaint();
                return array($val->value);
            } else {
                return array($node->name);
            }

        } elseif ($node instanceof PhpParser\Node\Expr\ArrayDimFetch) {
            if ($node->var instanceof PhpParser\Node\Expr\ArrayDimFetch) {
                $arr = $this->findVarNameAndDim($node->var, $taintTraverser, $taintVisitor);
            } else {
                $arr = array($node->var->name);
            }
            if ($node->dim !== null) {
                $taintTraverser->traverse(array($node->dim));
                $dimVal = $taintVisitor->getTaint();

                array_push($arr, $dimVal->value);
            } else {
                array_push($arr, VAR_REP_NEW);
            }
            return $arr;
        } elseif ($node instanceof PhpParser\Node\Expr\PropertyFetch) {
            $arr = $this->findVarNameAndDim($node->var, $taintTraverser, $taintVisitor);
            $arr[] = $node->name;
            return $arr;

        } elseif ($node->var instanceof PhpParser\Node\Expr\StaticPropertyFetch) {
            return array(
                VAR_REP_STATIC . $node->var->class->parts[0],
                $node->var->name
            );
        }
    }

    function checkAllCodePathsAtSink($varName, $sinkType = "xss"){
        //Check globalScope for tainted first
        global $globalVScope;
        $varTaintedInparent = false;
        $varInParent = $globalVScope->getVariableValue($varName);
        if($varInParent !== null && $varInParent->xss){
            $varTaintedInparent = true;
        }
    
        $groupedScopes = $this->vScope->getAllVariableValueConfigsGroups();

        $dependencies = array();
        $flowPath = array();
        $prevParentId = 0;
        $sanitizedOnAllCodePaths = null; //not true nor false until proved
        $parentAllSanitized = [];
        $lastSanitizedDependency = "";
        foreach ($groupedScopes as $key => $scopeGroup) {
            //groups are made up of if/elseif/else or cases of a switch
            if(count($scopeGroup) > 1){
                $sanitizedPaths = 0;
                $variableFoundOnce = false;
                foreach ($scopeGroup as $scope_) {
                    $sanitizedInScope = false;
                    $singleTaintInfo = $scope_->getVariableValue($varName, false);
                    if($singleTaintInfo !== null && $singleTaintInfo->userIput){
                        $variableFoundOnce = true;
                        if($singleTaintInfo->$sinkType){
                            $dependencies = array_merge($dependencies, $singleTaintInfo->dependencies);
                            $flowPath = array_merge($flowPath, $singleTaintInfo->flowPath);
                        }else{
                            $sanitizedPaths += 1;
                            $sanitizedInScope = true;
                        }
                    }
                    if(!$sanitizedInScope){
                        //just a check for if child nodes are all is sanitized
                        if(isset($parentAllSanitized[$scope_->id]) && $parentAllSanitized[$scope_->id]){
                            $sanitizedPaths += 1; //mark all codepath in scope as sanitized
                        }
                    }
                }
                if($scopeGroup[0]->parentId == 0){
                    //within the global scope;
                    $val = $sanitizedPaths == count($scopeGroup); //Sanitized on all paths in multi-conditiion
                    if($val){
                        $sanitizedOnAllCodePaths = true;
                        $lastSanitizedDependency = $scopeGroup[count($scopeGroup - 1)]->dependency;
                    }
                    //if it hasn't be proved true or false, it is false for now; if it has then set it back to what it was
                    $sanitizedOnAllCodePaths = $sanitizedOnAllCodePaths == null && $variableFoundOnce ? false : $sanitizedOnAllCodePaths;
                }else{
                    //condition in condition
                    //Should do a check if found once?
                    $parentAllSanitized[$scopeGroup[0]->parentId] = $sanitizedPaths == count($scopeGroup);
                }
                $prevParentId = $scopeGroup[0]->parentId;
            }else{
                $prevParentId = $scopeGroup[0]->parentId;
                //just an if in the group..or one case
                $singleTaintInfo = $scopeGroup[0]->getVariableValue($varName, false);
                if($singleTaintInfo !== null && $singleTaintInfo->userIput){
                    if($singleTaintInfo->$sinkType){
                        $dependencies = array_merge($dependencies, $singleTaintInfo->dependencies);
                        $flowPath = array_merge($flowPath, $singleTaintInfo->flowPath);
                    }
                    if($scopeGroup[0]->parentId == 0){
                        
                        //if it hasn't be proved true or false, it is false for now; if it has then set it back to what it was
                        $sanitizedOnAllCodePaths = $sanitizedOnAllCodePaths == null ? false : $sanitizedOnAllCodePaths;
                    }else{
                        //condition in condition
                        //this would mean that an only if is used as the first child node, hence set that the codepath isn't sanitized
                        if(!isset($parentAllSanitized[$scopeGroup[0]->parentId]) || !$parentAllSanitized[$scopeGroup[0]->parentId]){
                            $parentAllSanitized[$scopeGroup[0]->parentId] = false;
                        }
                    }
                }
            }
        }
        if($sanitizedOnAllCodePaths && !$varTaintedInparent){
            return [$varInParent, true]; //true means sanitization exists
        }
        if($sanitizedOnAllCodePaths && $varTaintedInparent){
            //I believe nodenumber would be better than linenumber due to file include cases
            //check that the last sanitization occurs after that last flowPath for the taintInParent
            //.php:36:
            $plineNumber = explode(":", substr($varInParent->flowpath[0], strpos($varInParent->flowpath[0], ".php")))[1];
            $lastSanLinNumber = explode(":", substr($lastSanitizedDependency, strpos($lastSanitizedDependency, ".php")))[1];
            $t = new VariableValue();
            if($lastSanLinNumber > $plineNumber){
                return [$t, true];
            }else{
                //The variable is re-tainted
                return [$varInParent, true]; //true means sanitization exists
            }
        }
        if($sanitizedOnAllCodePaths == null){
            //when it is null; it means variable was not in scopes; hence no sanitization;
            //So just return var in parent
            return [$varInParent, null]; //null means no sanitization exists
        }

        if($sanitizedOnAllCodePaths == false && $varTaintedInparent){
            //Sanitization not every where
            return [$varInParent, true]; //true means sanitization exists
        }
        if($sanitizedOnAllCodePaths == false && !$varTaintedInparent){
            //A taint was found in a scope
            $t = new VariableValue();
            $t->userInput = true;
            $t->$sinkType = true;
            $t->flowpath = array();
            $t->dependencies = $dependencies;
            $t->flowpath = $flowPath;
            return [$t, true];
        }

    }
}

$bodyVisitor = new BodyVisitor;
$bodyTraverser->addVisitor($bodyVisitor);

function printNode(PhpParser\Node $node, $omitInfo = false)
{
    global $prettyPrinter;
    $line = "";
    if (!$omitInfo) {
        $line .= $node->getAttribute("fileName") . ":" . $node->getLine() . ":";
    }

    $docComment = $node->getDocComment();
    $node->setAttribute("comments", null);
    $line .= $prettyPrinter->prettyPrint(array($node));
    $line = substr($line, 0, -1);
    if($docComment !== NULL){
        $node->setDocComment($docComment);
    }

    if ($node->getAttribute("THAPSComment") !== null) {
        $line .= " - " . $node->getAttribute("THAPSComment");
    }

    return $line;
}

function appendTaintInfo($taintInfo, $flowpath, $dependencies)
{
    if (is_array($taintInfo)) {
        foreach ($taintInfo as $tInfo) {
            appendTaintInfo($tInfo, $flowpath, $dependencies);
        }
    } elseif ($taintInfo instanceof VariableValue) {
        if ($taintInfo->userInput) {
            array_unshift($taintInfo->flowpath, $flowpath);
            $taintInfo->dependencies = array_merge($taintInfo->dependencies, $dependencies);
        }
    }
}

function prepareMultipleTaintInfo($taintInfos){
    $return = array();
    if(is_array($taintInfos)){
        $keys = array_keys($taintInfos);
        foreach ($keys as $key) {
            if(is_array($taintInfos[$key])){
                $val = prepareMultipleTaintInfo($taintInfos[$key]);
                $return = array_merge($return, $val);
            }else{
                $return = array_merge($return, array($key => $taintInfos[$key]));
            }
        }
    }
    return $return;
}

function squeezeTaints($taintInfo, $type = "any"){
    if(is_array($taintInfo)){
        $functionTaint = array_splice($taintInfo, 0, 1)[0];
        //If the function is dirty based on a particular type of vuln, or procedd to check any of the vulns
        if(count($taintInfo) > 1 && ($type == "any" || ($type !== "any" && $functionTaint->$type))){
            $otherTaint = array_splice($taintInfo, 1, count($taintInfo) - 1);
            $anyTaint = null;
            foreach ($otherTaint as $taintt) {
                if($type !== "any"){
                    $taintInfo = $taintt;
                    if($functionTaint->$type){
                        break;
                    }
                }else{
                    if($anyTaint == null){
                        $anyTaint = $taintt;
                    }else{
                        $anyTaint->userInput = $anyTaint->userInput || $taintt->userInput;
                        $anyTaint->xss = $anyTaint->xss || $taintt->xss;
                        $anyTaint->sql = $anyTaint->sql || $taintt->sql;
                        $anyTaint->fi = $anyTaint->fi || $taintt->fi;

                        if($taintt->userInput){
                            $anyTaint->flowpath = array_merge($anyTaint->flowpath, $taintt->flowpath);
                            $anyTaint->dependencies = array_merge($anyTaint->dependencies, $taintt->dependencies);
                            $anyTaint->value = $anyTaint->value . $taintt->value;
                        }
                    }
                }
            }
            if($type == "any"){
                $taintInfo = $anyTaint;
            }
        }else{
            $taintInfo = $functionTaint;
        }
    }
    return $taintInfo;
}

function squeezeArrayTaints($taintInfo){
    if(is_array($taintInfo)){
        $finalTaint = new VariableValue();
        foreach ($taintInfo as $taintt) {
            if(is_array($taintt)){
                $taintt = squeezeArrayTaints($taintt);
            }
            $finalTaint->userInput = $finalTaint->userInput || $taintt->userInput;
            $finalTaint->xss = $finalTaint->xss || $taintt->xss;
            $finalTaint->sql = $finalTaint->sql || $taintt->sql;
            $finalTaint->fi = $finalTaint->fi || $taintt->fi;
            $finalTaint->value = $finalTaint->value . $taintt->value;

            if($taintt->userInput){
                $finalTaint->flowpath = array_merge($finalTaint->flowpath, $taintt->flowpath);
                $finalTaint->dependencies = array_merge($finalTaint->dependencies, $taintt->dependencies);
            }
        }
        return $finalTaint;
    }else{
        return $taintInfo;
    }
}

